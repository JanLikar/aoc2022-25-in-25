# 2022 Advent of Code - 25 days in 25 languages

01 - Python
02 - Clojure
03 - Elixir
04 - C

In each of the languages I tried to follow the best practices to the best of my knowledge.
I am, however, familiar with only a handful of them, so don't hold it against me if I butchered them colossally.

## 25 Days
### 1. Python
I figured I would start with something I'm actually familiar with.

What can I say... Python is my primary language and I love it, dearly, so this was not a challenge at all.

Python is an excelent fit for solving tasks like these.

### 2. Clojure
As I don't have any real-world experience with lisps, I expected a decent Clojure solution would be harder for me to implement.

I was pleasently surprised - Clojure proved extremely expressive and nice to work with.

Converting my first PoC, which looked fairly similar to what an imperative solution would look like,
to a more idiomatic, functional solution was thoroughly rewarding.

### 3. Elixir
In a way this felt like Clojure with a different syntax.

String handling was slightly awkward, but I am sure that's because I didn't take enough time
to learn about Elixir's string types.

This task does not really allow Elixir's killer features to shine, but it was still a decent fit.

### 4. C
I haven't had the pleasere of using C in a long time, although it felt a bit like cheating to use
it for such a simple task that would have been easy in any of the languages on my list (short of assembly). On the other hand, I would rather save the languages I am less familiar with for more interesting tasks.

## Future Ideas
Bash
PHP
Javascript
Java
OCaml
Haskell
Elm
Rust
Go
C++
Perl
Julia
C#
Ruby
Lua
Scheme
Matlab
Kotlin
Swift
R
Fortran
D
Scala
x86 assembly
